import { getData } from './dataStore';
import crypto from 'crypto';

/*
generates a unique random ID for the user using the unique id of the user
arguments: uId - integer - the id of the user the token is being generated for.
returns: a random string with a hyphen and uid appended to the string.
*/

// Attribution: The value of random was generated by using the method specified on this
// website: https://thewebdev.info/2021/10/how-to-create-a-random-token-in-javascript/
function generateToken(uId: number) {
  const random = Math.random().toString(36).substring(2);
  return random.concat('-' + uId.toString());
}

/*
returns the userId of a user based upon the token they currently have.
arguments: token - string - the token the user is currently logged in with
returns: the user's id when the token exists.
null when the token is currently not used by a user.
*/
function getUIdfromtoken(token: string) {
  const data = getData();
  for (const key of data.users) {
    for (let i = 0; i < key.tokens.length; i++) {
      if (key.tokens[i] === token) {
        return key.uId as number; // added 'as number', revert back if there are issues
      }
    }
  }
  return null;
}

/*
This function allows a verified user access to the information of another user of the software.
This information includes the users email, first and last name as well as their unique handle.

arguments:
authUserId - integer - the user who is searching the database for another user
uId - integer - the user being searched for

returns:
error - object string - if the user doesn't exist or the user being searched for doesn't exist.
user - object - user's Id, first and last name and unique handle.
*/

function userProfile(authUserId: number, uId: number) {
  // Gives access to the dataStore database via a local variable.
  const dataBase = getData();

  // Check if authUserId is a valid user
  if (dataBase.users.find((user: any) => user.uId === authUserId)) {
    // Check if user exists within the user array
    if (dataBase.users.find((user: any) => user.uId === uId)) {
      // Search for user of interest and store the details.
      const userOfInterest = dataBase.users.find(
        (user: any) => user.uId === uId
      );
      // return user information.
      return {
        uId: userOfInterest.uId,
        email: userOfInterest.email,
        nameFirst: userOfInterest.nameFirst,
        nameLast: userOfInterest.nameLast,
        handleStr: userOfInterest.handleStr,
      };
    }
  }
}

// Returns the number of tokens held by a user.
function numberOfTokens(uId: number) {
  const data = getData();
  const user = data.users.find((user: any) => user.uId === uId);
  return user.tokens.length;
}

// Returns the number of owners of a channel.
function numberOfOwnersOfChannel(channelId: number) {
  const database = getData();
  const channel = database.channels.find(
    (channel: any) => channel.channelId === channelId
  );
  return channel.ownerMembers.length;
}

/* Generates a Hash based on the input parameter of the function

arguments:
text - string - a word or phrase to be hashed

returns:
Hash - string - Non reversible encrypted string based on the input to the function.
*/
function getHashOf(text: string) {
  const secret = 'sayNoToFriedIceCream';
  return crypto
    .createHash('sha256')
    .update(text + secret)
    .digest('hex');
}

/**
 * Checks the received hashed token against those stored under the user and returns
 * the original token
 * @param hashedToken
 * @returns if hashed token is valid the original token is returned otherwise an invalid token is returned
 */
// function checkHashedToken(hashedToken: string) {
//   const data = getData();
//   const validUser = data.users.find(
//     (user: any) => user.hashedTokens === hashedToken
//   );
//   if (!validUser) {
//     return '$notAToken$';
//   } else {
//     // Loop through all the tokens and hash them and compare them to hashedToken
//     for (const eachToken of validUser.tokens) {
//       if (getHashOf(eachToken) === hashedToken) {
//         return eachToken;
//       }
//     }
//   }
// }

/**
 * Finds the ratio of channel members to users of UNSW Treats
 * @returns - number: Utilization, which is the ratio of the number
 * of users who have joined at least one channel over the number of users
 */
function utilization() {
  const data = getData();
  // determine number of users who have joined at least one channel/DM
  let numUsersJoinedAtLeast1Channel = 0;
  const numOfUsers = data.users.length;
  let memberOfAChannel = false;
  if (numOfUsers !== 0) {
    for (const eachUser of data.users) {
      memberOfAChannel = false;
      for (const channel of data.channels) {
        if (channel.allMembers.find((member: any) => member === eachUser.uId)) {
          if (memberOfAChannel === false) {
            numUsersJoinedAtLeast1Channel++;
            memberOfAChannel = true;
          }
        }
      }
      if (memberOfAChannel === true) {
        memberOfAChannel = false;
      } else {
        for (const dm of data.dms) {
          if (dm.allMembers.find((member: any) => member === eachUser.uId)) {
            if (memberOfAChannel === false) {
              numUsersJoinedAtLeast1Channel++;
              memberOfAChannel = true;
            }
          }
        }
      }
    }
    return numUsersJoinedAtLeast1Channel / numOfUsers;
  }
  return 0;
}

function getResetCode(token: string) {
  const data = getData();
  for (const user of data.users) {
    for (const tokens of user.tokens) {
      if (tokens === token) {
        return user.resetCode;
      }
    }
  }
}

export {
  userProfile,
  getUIdfromtoken,
  generateToken,
  numberOfTokens,
  numberOfOwnersOfChannel,
  getHashOf,
  utilization,
  getResetCode,
};
